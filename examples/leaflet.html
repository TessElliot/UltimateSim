<!DOCTYPE html>
<html>
<head>
    <title>Bounding Boxes Visualization</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map { height: 600px; }
        .leaflet-label { font-size: 12px; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Bounding Boxes Visualization</h1>
    <div id="map"></div>

    <h2>Initial Bounding Box</h2>
    <p id="initialBox"></p>

    <h2>Spiral Bounding Boxes</h2>
    <ul id="spiralBoxes"></ul>

    <h2>Grid Bounding Boxes</h2>
    <ul id="gridBoxes"></ul>

    <h2>Matching Bounding Boxes</h2>
    <ul id="matchingBoxes"></ul>

    <h2>Non-Matching Bounding Boxes</h2>
    <ul id="nonMatchingBoxes"></ul>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        window.onload = function() {
            const map = L.map('map').setView([35.1924702, -97.4439916], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18,
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);

            // Define colors
            const colors = {
                matching: "red",
                gridOnly: "blue",
                spiralOnly: "green"
            };

            // Arrays to store bounding boxes generated by each function
            const spiralBoundingBoxes = [];
            const gridBoundingBoxes = [];

            // Initial bounding box values
            const minLat = 35.2108403;
            const minLon = -97.4428013;
            const maxLat = minLat + 0.026;
            const maxLon = minLon + 0.026;
            const countX = 10;
            const countY = 10; // Set to a valid non-zero value

            // Display the initial bounding box
            document.getElementById("initialBox").textContent = `Initial Bounding Box: (${minLat}, ${minLon}) - (${maxLat}, ${maxLon})`;

            // Function to generate bounding boxes in a spiral pattern
            // function generateSpiralBoundingBoxes(minLat, minLon, maxLat, maxLon, countX, countY) {
            //     const latDiff = (maxLat - minLat) / countY;
            //     const lonDiff = (maxLon - minLon) / countX;
            //     const directions = [
            //         [0, 1],  // right
            //         [1, 0],   // down
            //         [0, -1],   // left
            //         [-1, 0]   // up
            //     ];
            //     let dirIndex = 0;
            //     let steps = 1;
            //     let stepsTaken = 0;
            //     let x = Math.floor(countX / 2);
            //     let y = Math.floor(countY / 2);

            //     for (let i = 0; i < countX * countY; i++) {
            //         const newMinLat = minLat + (y - Math.floor(countY / 2)) * latDiff;
            //         const newMinLon = minLon + (x - Math.floor(countX / 2)) * lonDiff;
            //         const newMaxLat = newMinLat + latDiff;
            //         const newMaxLon = newMinLon + lonDiff;

            //         spiralBoundingBoxes.push({
            //             minLat: newMinLat.toFixed(6),
            //             minLon: newMinLon.toFixed(6),
            //             maxLat: newMaxLat.toFixed(6),
            //             maxLon: newMaxLon.toFixed(6)
            //         });

            //         const [dx, dy] = directions[dirIndex];
            //         x += dx;
            //         y += dy;
            //         stepsTaken++;

            //         if (stepsTaken === steps) {
            //             dirIndex = (dirIndex + 1) % 4;
            //             stepsTaken = 0;
            //             if (dirIndex % 2 === 0) {
            //                 steps++;
            //             }
            //         }
            //     }
            // }

            function generateSpiralBoundingBoxes(
  minLat,
  minLon,
  maxLat,
  maxLon,
  countX,
  countY
) {
  const latDiff = (maxLat - minLat);
  const lonDiff = (maxLon - minLon);
  const boundingBoxes = [];
  const directions = [
    [0, 1], // Right
    [1, 0], // Down
    [0, -1], // Left
    [-1, 0], // Up
  ];
  let dirIndex = 0;
  let steps = 1;
  let stepsTaken = 0;
  let x = Math.floor(countX / 2);
  let y = Math.floor(countY / 2);

  for (let i = 0; i < countX * countY; i++) {
    const newMinLat = minLat + (y - Math.floor(countY / 2)) * latDiff;
    const newMinLon = minLon + (x - Math.floor(countX / 2)) * lonDiff;
    const newMaxLat = newMinLat + latDiff;
    const newMaxLon = newMinLon + lonDiff;

    spiralBoundingBoxes.push({
      minLat: parseFloat(newMinLat.toFixed(6)),
      minLon: parseFloat(newMinLon.toFixed(6)),
      maxLat: parseFloat(newMaxLat.toFixed(6)),
      maxLon: parseFloat(newMaxLon.toFixed(6)),
      x: x, // Store grid coordinates for spiral layout
      y: y,
      order: i + 1,
    });

    const [dx, dy] = directions[dirIndex];
    x += dx;
    y += dy;
    stepsTaken++;

    if (stepsTaken === steps) {
      dirIndex = (dirIndex + 1) % 4;
      stepsTaken = 0;
      if (dirIndex % 2 === 0) {
        steps++;
      }
    }
  }

 
}













            function generateBoundingBoxes(minLat, minLon, maxLat, maxLon, countX, countY) {
         const latDiff = (maxLat - minLat) ;
           const lonDiff = (maxLon - minLon) / couX;

    // Calculate the center position index
         const centerX = Math.floor(countX / 2);
        const centerY = Math.floor(countY / 2);

    for (let i = countY; i > 0; i--) {
        for (let j = 0; j < countX; j++) {
            const newMinLat = minLat + (i - centerY) * latDiff;
            const newMinLon = minLon + (j - centerX) * lonDiff;
            const newMaxLat = newMinLat + latDiff;
            const newMaxLon = newMinLon + lonDiff;

            // Push each bounding box directly to gridBoundingBoxes
            gridBoundingBoxes.push({
                minLat: newMinLat.toFixed(6),
                minLon: newMinLon.toFixed(6),
                maxLat: newMaxLat.toFixed(6),
                maxLon: newMaxLon.toFixed(6)
            });
        }
    }
}



        

            // Function to compare bounding boxes based on coordinates
            function findMatchingBoxes() {
                const matchingBoxes = [];
                const spiralOnlyBoxes = [];
                const gridOnlyBoxes = [...gridBoundingBoxes];

                spiralBoundingBoxes.forEach(spiralBox => {
                    const matchIndex = gridOnlyBoxes.findIndex(gridBox => 
                        gridBox.minLat === spiralBox.minLat &&
                        gridBox.minLon === spiralBox.minLon &&
                        gridBox.maxLat === spiralBox.maxLat &&
                        gridBox.maxLon === spiralBox.maxLon
                    );

                    if (matchIndex !== -1) {
                        matchingBoxes.push(spiralBox);
                        gridOnlyBoxes.splice(matchIndex, 1);  // Remove from gridOnly if matched
                    } else {
                        spiralOnlyBoxes.push(spiralBox);
                    }
                });

                return { matchingBoxes, spiralOnlyBoxes, gridOnlyBoxes };
            }

            // Function to display bounding boxes on the map
            function drawBoundingBoxes(boundingBoxes, color, labelPrefix) {
                boundingBoxes.forEach((box, index) => {
                    const bounds = [
                        [box.minLat, box.minLon],
                        [box.maxLat, box.maxLon]
                    ];
                    const rectangle = L.rectangle(bounds, { color: color, weight: 2 }).addTo(map);
                    const label = `${labelPrefix}${index + 1}`;
                    rectangle.bindTooltip(label, { permanent: true, className: "leaflet-label" }).openTooltip();
                });
            }

            // Display bounding boxes on the HTML page and map
            function displayBoundingBoxes() {
                const spiralList = document.getElementById("spiralBoxes");
                const gridList = document.getElementById("gridBoxes");
                const matchingList = document.getElementById("matchingBoxes");
                const nonMatchingList = document.getElementById("nonMatchingBoxes");

                // Display spiral bounding boxes
                spiralBoundingBoxes.forEach(box => {
                    const listItem = document.createElement("li");
                    listItem.textContent = `(${box.minLat}, ${box.minLon}) - (${box.maxLat}, ${box.maxLon})`;
                    spiralList.appendChild(listItem);
                });

                // Display grid bounding boxes
                gridBoundingBoxes.forEach(box => {
                    const listItem = document.createElement("li");
                    listItem.textContent = `(${box.minLat}, ${box.minLon}) - (${box.maxLat}, ${box.maxLon})`;
                    gridList.appendChild(listItem);
                });

                // Get matching and non-matching bounding boxes
                const { matchingBoxes, spiralOnlyBoxes, gridOnlyBoxes } = findMatchingBoxes();

                // Display matching and non-matching bounding boxes
                matchingBoxes.forEach(box => {
                    const listItem = document.createElement("li");
                    listItem.textContent = `Matching Box: (${box.minLat}, ${box.minLon}) - (${box.maxLat}, ${box.maxLon})`;
                    matchingList.appendChild(listItem);
                });

                spiralOnlyBoxes.forEach(box => {
                    const listItem = document.createElement("li");
                    listItem.textContent = `Non-Matching Spiral Box: (${box.minLat}, ${box.minLon}) - (${box.maxLat}, ${box.maxLon})`;
                    nonMatchingList.appendChild(listItem);
                });

                gridOnlyBoxes.forEach(box => {
                    const listItem = document.createElement("li");
                    listItem.textContent = `Non-Matching Grid Box: (${box.minLat}, ${box.minLon}) - (${box.maxLat}, ${box.maxLon})`;
                    nonMatchingList.appendChild(listItem);
                });

                // Draw bounding boxes on the map
                drawBoundingBoxes(matchingBoxes, colors.matching, "M");
                drawBoundingBoxes(gridOnlyBoxes, colors.gridOnly, "G");
                drawBoundingBoxes(spiralOnlyBoxes, colors.spiralOnly, "S");
            }

            // Generate and display bounding boxes
            generateSpiralBoundingBoxes(minLat, minLon, maxLat, maxLon, countX, countY);
            // generateBoundingBoxes(minLat, minLon, maxLat, maxLon, countX, countY);
            displayBoundingBoxes();
        }
    </script>
</body>
</html>
